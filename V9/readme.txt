上一个版本中我们将响应的部分进行了重构，此版本尝试在页面中加载一张图片


步骤:
1:在webapps/myweb目录下添加一张图片
2:在该目录中的index.html上添加对图片的显示
3:启动服务端请求该页面，查看图片是否被正确加载

测试后发现图片不能正常显示
原因:
当浏览器请求页面后(一问一答完成)在解析页面时发现页面上需要加载其他的资
源时(比如index.html页面上要显示一张图片)，浏览器会按照该资源指定的路
径再次发起请求去下载这个资源来进行显示。由于我们的服务端目前只接受一次
请求后就关闭了，所以导致浏览器再次连接服务端时失败，从而无法下载并显示
这张图片。

由于我们已经完成了一问一答的流程，因此我们可以在WebServer类的start方法
中将接受客户端连接并启动线程处理的工作改为在死循环中进行了，这样一来服务
端就可以重复接收请求了。



完成上述工作后，再做另一个工作:
从doc.canglaoshi.org网站上下载稻草问答或学子商城的静态页面素材，并
导入到webapps目录下作为一个网络应用。然后尝试访问其中的首页index.html

请求后发现页面不能完整的正确显示出来。
原因:
由于页面上需要加载很多其他资源，比如css文件，js文件等。
但是我们现在代码的实现中发送响应的响应头中说明响应正文的类型:
Content-Type给的值是固定的text/html(HttpResponse的sendHeaders方法)
因此无论浏览器现在请求什么样的资源我们响应时都告知是text/html即“页面”
这就导致浏览器无法正确理解其请求的资源从而不能发挥这个资源应有的效果。
最终导致页面无法正确完整显示出来。


解决:
对HttpResponse发送响应头的代码进行重构，重构做两件事:
1:响应头的发送不是让sendHeaders方法发送固定的两个头，而是设置什么
  响应头就发送什么响应头
  这样的好处是，将来如果需要发送其他响应头也是可以发送的。


2:发送Content-Type时要根据响应正文的文件类型发送对应的值。




实现:
先重构sendHeaders方法
1:在HttpResponse中定义一个Map用于保存所有要给客户端发送的响应头
2:将sendHeaders方法中原有的固定发送两个响应头改为遍历Map，将需要
  发送的响应头全部发送。
3:在HttpResponse中添加一个方法putHeader()允许外界设置要发送的响应头
  方法内部仅需要将给定的响应头添加到Map中即可。











































